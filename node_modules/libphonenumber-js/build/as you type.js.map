{"version":3,"sources":["../source/as you type.js"],"names":["metadata","as_you_type","country_code","countries","default_country","reset","text","extracted_number","indexOf","VALID_INCOMPLETE_PHONE_NUMBER_PATTERN","current_output","process_input","input","parsed_input","reset_countriness","slice","valid","national_number","is_international","country_phone_code","extract_country_phone_code","initialize_phone_number_formats_for_this_country_phone_code","reset_format","determine_the_country","country","previous_national_prefix","national_prefix","extract_national_prefix","matching_formats","available_formats","formatted_national_phone_number","format_national_phone_number","full_phone_number","next_digits","national_number_formatted_with_previous_format","chosen_format","format_next_national_number_digits","formatted_number","attempt_to_format_complete_phone_number","match_formats_by_leading_digits","choose_another_format","reformat_national_number","undefined","reset_country","country_metadata","phone_code","template","partially_populated_template","last_match_position","filter","format","ELIGIBLE_FORMAT_PATTERN","test","sort","a","b","length","leading_digits","index_of_leading_digits_pattern","MIN_LEADING_DIGITS_LENGTH","get_relevant_phone_number_formats","leading_digits_pattern_count","leading_digits_pattern_index","Math","min","leading_digits_pattern","RegExp","matcher","validate_format","create_formatting_template","full_number","replace","DIGIT_PLACEHOLDER","formatted_national_number","number","national_prefix_for_parsing","matches","match","national_number_starts_at","national_prefix_formatting_rule","number_pattern","CHARACTER_CLASS_PATTERN","STANDALONE_DIGIT_PATTERN","dummy_phone_number_matching_format_pattern","LONGEST_DUMMY_PHONE_NUMBER","number_format","get_format_format","DUMMY_DIGIT_MATCHER","repeat","digits","digit","search","DIGIT_PLACEHOLDER_MATCHER","close_dangling_braces","DIGIT_PLACEHOLDER_MATCHER_GLOBAL","count_occurences","DUMMY_DIGIT","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","VALID_INCOMPLETE_PHONE_NUMBER","cut_before","retained_template","opening_braces","closing_braces","dangling_braces","symbol","string","count","character","times","result"],"mappings":"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","file":"as you type.js","sourcesContent":["// This is an enhanced port of Google Android `libphonenumber`'s\n// `asyoutypeformatter.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\n\nimport\n{\n\tget_phone_code,\n\tget_national_prefix,\n\tget_national_prefix_for_parsing,\n\tget_formats,\n\tget_format_pattern,\n\tget_format_format,\n\tget_format_international_format,\n\tget_format_national_prefix_formatting_rule,\n\tget_format_national_prefix_is_optional_when_formatting,\n\tget_format_national_prefix_is_mandatory_when_formatting,\n\tget_format_leading_digits_patterns,\n\tget_metadata_by_country_phone_code\n}\nfrom './metadata'\n\nimport\n{\n\tVALID_PUNCTUATION,\n\tPLUS_SIGN,\n\tPLUS_CHARS,\n\tVALID_DIGITS,\n\textract_formatted_phone_number,\n\tparse_phone_number,\n\tparse_phone_number_and_country_phone_code,\n\tfind_country_code\n}\nfrom './parse'\n\nimport\n{\n\tFIRST_GROUP_PATTERN,\n\tformat_national_number_using_format,\n\tlocal_to_international_style\n}\nfrom './format'\n\nimport\n{\n\tmatches_entirely\n}\nfrom './common'\n\n// Used in phone number format template creation.\n// Could be any digit, I guess.\nconst DUMMY_DIGIT = '9'\nconst DUMMY_DIGIT_MATCHER = new RegExp(DUMMY_DIGIT, 'g')\n// I don't know why is it exactly `15`\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\n// Create a phone number consisting only of the digit 9 that matches the\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\n\n// The digits that have not been entered yet will be represented by a \\u2008,\n// the punctuation space.\nconst DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\nconst DIGIT_PLACEHOLDER_MATCHER_GLOBAL = new RegExp(DIGIT_PLACEHOLDER, 'g')\n\n// A pattern that is used to match character classes in regular expressions.\n// An example of a character class is \"[1-4]\".\nconst CHARACTER_CLASS_PATTERN = /\\[([^\\[\\]])*\\]/g\n\n// Any digit in a regular expression that actually denotes a digit. For\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\n// (8 and 0) are standalone digits, but the rest are not.\n// Two look-aheads are needed because the number following \\\\d could be a\n// two-digit number, since the phone number can be as long as 15 digits.\nconst STANDALONE_DIGIT_PATTERN = /\\d(?=[^,}][^,}])/g\n\n// A pattern that is used to determine if a `format` is eligible\n// to be used by the \"as you type formatter\".\n// It is eligible when the `format` contains groups of the dollar sign\n// followed by a single digit, separated by valid phone number punctuation.\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\n// getting into the output of the \"as you type formatter\".\nconst ELIGIBLE_FORMAT_PATTERN = new RegExp\n(\n\t'^' +\n\t'[' + VALID_PUNCTUATION + ']*' +\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' +\n\t'$'\n)\n\n// This is the minimum length of the leading digits of a phone number\n// to guarantee the first \"leading digits pattern\" for a phone number format\n// to be preemptive.\nconst MIN_LEADING_DIGITS_LENGTH = 3\n\nconst VALID_INCOMPLETE_PHONE_NUMBER =\n\t'[' + PLUS_CHARS + ']{0,1}' +\n\t'[' +\n\t\tVALID_PUNCTUATION +\n\t\tVALID_DIGITS +\n\t']*'\n\nconst VALID_INCOMPLETE_PHONE_NUMBER_PATTERN = new RegExp('^' + VALID_INCOMPLETE_PHONE_NUMBER + '$', 'i')\n\nexport default function(metadata)\n{\n\tclass as_you_type\n\t{\n\t\tconstructor(country_code)\n\t\t{\n\t\t\tif (country_code && metadata.countries[country_code])\n\t\t\t{\n\t\t\t\tthis.default_country = country_code\n\t\t\t}\n\n\t\t\tthis.reset()\n\t\t}\n\n\t\tinput(text)\n\t\t{\n\t\t\t// Parse input\n\n\t\t\tlet extracted_number = extract_formatted_phone_number(text)\n\n\t\t\t// Special case for a lone '+' sign\n\t\t\t// since it's not considered a possible phone number.\n\t\t\tif (!extracted_number)\n\t\t\t{\n\t\t\t\tif (text && text.indexOf('+') >= 0)\n\t\t\t\t{\n\t\t\t\t\textracted_number = '+'\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Validate possible first part of a phone number\n\t\t\tif (!matches_entirely(extracted_number, VALID_INCOMPLETE_PHONE_NUMBER_PATTERN))\n\t\t\t{\n\t\t\t\treturn this.current_output\n\t\t\t}\n\n\t\t\treturn this.process_input(parse_phone_number(extracted_number))\n\t\t}\n\n\t\tprocess_input(input)\n\t\t{\n\t\t\t// If an out of position '+' sign detected\n\t\t\t// (or a second '+' sign),\n\t\t\t// then just drop it from the input.\n\t\t\tif (input[0] === '+')\n\t\t\t{\n\t\t\t\tif (!this.parsed_input)\n\t\t\t\t{\n\t\t\t\t\tthis.parsed_input += '+'\n\n\t\t\t\t\t// If a default country was set\n\t\t\t\t\t// then reset it because an explicitly international\n\t\t\t\t\t// phone number is being entered\n\t\t\t\t\tthis.reset_countriness()\n\t\t\t\t}\n\n\t\t\t\tinput = input.slice(1)\n\t\t\t}\n\n\t\t\t// Raw phone number\n\t\t\tthis.parsed_input += input\n\n\t\t\t// Reset phone number validation state\n\t\t\tthis.valid = false\n\n\t\t\t// Add digits to the national number\n\t\t\tthis.national_number += input\n\n\t\t\t// Try to format the parsed input\n\n\t\t\tif (this.is_international())\n\t\t\t{\n\t\t\t\tif (!this.country_phone_code)\n\t\t\t\t{\n\t\t\t\t\t// If one looks at country phone codes\n\t\t\t\t\t// then he can notice that no one country phone code\n\t\t\t\t\t// is ever a (leftmost) substring of another country phone code.\n\t\t\t\t\t// So if a valid country code is extracted so far\n\t\t\t\t\t// then it means that this is the country code.\n\n\t\t\t\t\t// If no country phone code could be extracted so far,\n\t\t\t\t\t// then just return the raw phone number,\n\t\t\t\t\t// because it has no way of knowing\n\t\t\t\t\t// how to format the phone number so far.\n\t\t\t\t\tif (!this.extract_country_phone_code())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Return raw phone number\n\t\t\t\t\t\treturn this.parsed_input\n\t\t\t\t\t}\n\n\t\t\t\t\t// Initialize country-specific data\n\t\t\t\t\tthis.initialize_phone_number_formats_for_this_country_phone_code()\n\t\t\t\t\tthis.reset_format()\n\t\t\t\t\tthis.determine_the_country()\n\t\t\t\t}\n\t\t\t\t// `this.country` could be `undefined`,\n\t\t\t\t// for instance, when there is ambiguity\n\t\t\t\t// in a form of several different countries\n\t\t\t\t// each corresponding to the same country phone code\n\t\t\t\t// (e.g. NANPA: USA, Canada, etc),\n\t\t\t\t// and there's not enough digits entered\n\t\t\t\t// to reliably determine the country\n\t\t\t\t// the phone number belongs to.\n\t\t\t\t// Therefore, in cases of such ambiguity,\n\t\t\t\t// each time something is input,\n\t\t\t\t// try to determine the country\n\t\t\t\t// (if it's not determined yet).\n\t\t\t\telse if (!this.country)\n\t\t\t\t{\n\t\t\t\t\tthis.determine_the_country()\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Some national prefixes are substrings of other national prefixes\n\t\t\t\t// (for the same country), therefore try to extract national prefix each time\n\t\t\t\t// because a longer national prefix might be available at some point in time.\n\n\t\t\t\tconst previous_national_prefix = this.national_prefix\n\t\t\t\tthis.national_number = this.national_prefix + this.national_number\n\n\t\t\t\t// Possibly extract a national prefix\n\t\t\t\tthis.extract_national_prefix()\n\n\t\t\t\tif (this.national_prefix !== previous_national_prefix)\n\t\t\t\t{\n\t\t\t\t\t// National number has changed\n\t\t\t\t\t// (due to another national prefix been extracted)\n\t\t\t\t\t// therefore national number has changed\n\t\t\t\t\t// therefore reset all previous formatting data.\n\t\t\t\t\t// (and leading digits matching state)\n\t\t\t\t\tthis.matching_formats = this.available_formats\n\t\t\t\t\tthis.reset_format()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Format the phone number (given the next digits)\n\t\t\tconst formatted_national_phone_number = this.format_national_phone_number(input)\n\n\t\t\t// If the phone number could be formatted,\n\t\t\t// then return it, possibly prepending with country phone code\n\t\t\t// (for international phone numbers only)\n\t\t\tif (formatted_national_phone_number)\n\t\t\t{\n\t\t\t\treturn this.full_phone_number(formatted_national_phone_number)\n\t\t\t}\n\n\t\t\t// If the phone number couldn't be formatted,\n\t\t\t// then just fall back to the raw phone number.\n\t\t\treturn this.parsed_input\n\t\t}\n\n\t\tformat_national_phone_number(next_digits)\n\t\t{\n\t\t\t// Format the next phone number digits\n\t\t\t// using the previously chosen phone number format.\n\t\t\t//\n\t\t\t// This is done here because if `attempt_to_format_complete_phone_number`\n\t\t\t// was placed before this call then the `template`\n\t\t\t// wouldn't reflect the situation correctly (and would therefore be inconsistent)\n\t\t\t//\n\t\t\tlet national_number_formatted_with_previous_format\n\t\t\tif (this.chosen_format)\n\t\t\t{\n\t\t\t\tnational_number_formatted_with_previous_format = this.format_next_national_number_digits(next_digits)\n\t\t\t}\n\n\t\t\t// See if the input digits can be formatted properly already. If not,\n\t\t\t// use the results from format_next_national_number_digits(), which does formatting\n\t\t\t// based on the formatting pattern chosen.\n\n\t\t\tconst formatted_number = this.attempt_to_format_complete_phone_number()\n\n\t\t\tif (formatted_number)\n\t\t\t{\n\t\t\t\tif (this.country)\n\t\t\t\t{\n\t\t\t\t\tthis.valid = true\n\t\t\t\t}\n\n\t\t\t\treturn formatted_number\n\t\t\t}\n\n\t\t\t// Check if the previously chosen phone number format still holds\n\t\t\tthis.match_formats_by_leading_digits()\n\n\t\t\t// If the previously chosen phone number format\n\t\t\t// didn't match the next (current) digit being input\n\t\t\t// (leading digits pattern didn't match).\n\t\t\tif (this.choose_another_format())\n\t\t\t{\n\t\t\t\t// And a more appropriate phone number format\n\t\t\t\t// has been chosen for these `leading digits`,\n\t\t\t\t// then format the national phone number (so far)\n\t\t\t\t// using the newly selected phone number pattern.\n\n\t\t\t\t// Will return `undefined` if it couldn't format\n\t\t\t\t// the supplied national number\n\t\t\t\t// using the selected phone number pattern.\n\n\t\t\t\treturn this.reformat_national_number()\n\t\t\t}\n\n\t\t\t// If could format the next (current) digit\n\t\t\t// using the previously chosen phone number format\n\t\t\t// then return the formatted number so far.\n\n\t\t\t// If no new phone number format could be chosen,\n\t\t\t// and couldn't format the supplied national number\n\t\t\t// using the selected phone number pattern,\n\t\t\t// then it will return `undefined`.\n\n\t\t\treturn national_number_formatted_with_previous_format\n\t\t}\n\n\t\treset()\n\t\t{\n\t\t\t// Input stripped of non-phone-number characters.\n\t\t\t// Can only contain a possible leading '+' sign and digits.\n\t\t\tthis.parsed_input = ''\n\n\t\t\tthis.current_output = ''\n\n\t\t\t// This contains the national prefix that has been extracted. It contains only\n\t\t\t// digits without formatting.\n\t\t\tthis.national_prefix = ''\n\n\t\t\tthis.national_number = ''\n\n\t\t\tthis.reset_countriness()\n\n\t\t\tthis.reset_format()\n\n\t\t\tthis.valid = false\n\n\t\t\treturn this\n\t\t}\n\n\t\treset_country()\n\t\t{\n\t\t\tif (this.default_country && !this.is_international())\n\t\t\t{\n\t\t\t\tthis.country = this.default_country\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.country = undefined\n\t\t\t}\n\t\t}\n\n\t\treset_countriness()\n\t\t{\n\t\t\tthis.reset_country()\n\n\t\t\tif (this.default_country && !this.is_international())\n\t\t\t{\n\t\t\t\tthis.country_metadata = metadata.countries[this.default_country]\n\t\t\t\tthis.country_phone_code = this.country_metadata.phone_code\n\n\t\t\t\tthis.initialize_phone_number_formats_for_this_country_phone_code()\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.country_metadata = undefined\n\t\t\t\tthis.country_phone_code = undefined\n\n\t\t\t\tthis.available_formats = []\n\t\t\t\tthis.matching_formats = this.available_formats\n\t\t\t}\n\t\t}\n\n\t\treset_format()\n\t\t{\n\t\t\tthis.chosen_format = undefined\n\t\t\tthis.template = undefined\n\t\t\tthis.partially_populated_template = undefined\n\t\t\tthis.last_match_position = -1\n\t\t}\n\n\t\t// Format each digit of national phone number (so far)\n\t\t// using the newly selected phone number pattern.\n\t\treformat_national_number()\n\t\t{\n\t\t\t// Format each digit of national phone number (so far)\n\t\t\t// using the selected phone number pattern.\n\t\t\treturn this.format_next_national_number_digits(this.national_number)\n\t\t}\n\n\t\tinitialize_phone_number_formats_for_this_country_phone_code()\n\t\t{\n\t\t\t// Get all \"eligible\" phone number formats for this country\n\t\t\tthis.available_formats = get_formats(this.country_metadata).filter((format) =>\n\t\t\t{\n\t\t\t\treturn ELIGIBLE_FORMAT_PATTERN.test(get_format_international_format(format))\n\t\t\t})\n\t\t\t// Try the formats with \"leading digits\" defined first\n\t\t\t.sort((a, b) =>\n\t\t\t{\n\t\t\t\t// Leading digits are defined for most formats\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (get_format_leading_digits_patterns(a).length === 0\n\t\t\t\t\t&& get_format_leading_digits_patterns(b).length > 0)\n\t\t\t\t{\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\n\t\t\t\t// Leading digits are defined for most formats\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (get_format_leading_digits_patterns(a).length > 0\n\t\t\t\t\t&& get_format_leading_digits_patterns(b).length === 0)\n\t\t\t\t{\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\n\t\t\t\treturn 0\n\t\t\t})\n\n\t\t\tthis.matching_formats = this.available_formats\n\t\t}\n\n\t\tmatch_formats_by_leading_digits()\n\t\t{\n\t\t\tconst leading_digits = this.national_number\n\n\t\t\t// \"leading digits\" patterns start with a maximum 3 digits,\n\t\t\t// and then with each additional digit\n\t\t\t// a more precise \"leading digits\" pattern is specified.\n\t\t\t// They could make \"leading digits\" patterns start\n\t\t\t// with a maximum of a single digit, but they didn't,\n\t\t\t// so it's possible that some phone number formats\n\t\t\t// will be falsely rejected until there are at least\n\t\t\t// 3 digits in the national (significant) number being input.\n\n\t\t\tlet index_of_leading_digits_pattern = leading_digits.length - MIN_LEADING_DIGITS_LENGTH\n\n\t\t\tif (index_of_leading_digits_pattern < 0)\n\t\t\t{\n\t\t\t\tindex_of_leading_digits_pattern = 0\n\t\t\t}\n\n\t\t\tthis.matching_formats = this.get_relevant_phone_number_formats().filter((format) =>\n\t\t\t{\n\t\t\t\tconst leading_digits_pattern_count = get_format_leading_digits_patterns(format).length\n\n\t\t\t\t// Keep everything that isn't restricted by leading digits.\n\t\t\t\tif (leading_digits_pattern_count === 0)\n\t\t\t\t{\n\t\t\t\t\treturn true\n\t\t\t\t}\n\n\t\t\t\tconst leading_digits_pattern_index = Math.min(index_of_leading_digits_pattern, leading_digits_pattern_count - 1)\n\t\t\t\tconst leading_digits_pattern = get_format_leading_digits_patterns(format)[leading_digits_pattern_index]\n\t\t\t\treturn new RegExp('^' + leading_digits_pattern).test(leading_digits)\n\t\t\t})\n\t\t}\n\n\t\tget_relevant_phone_number_formats()\n\t\t{\n\t\t\tconst leading_digits = this.national_number\n\n\t\t\t// \"leading digits\" patterns start with a maximum 3 digits,\n\t\t\t// and then with each additional digit\n\t\t\t// a more precise \"leading digits\" pattern is specified.\n\t\t\t// They could make \"leading digits\" patterns start\n\t\t\t// with a maximum of a single digit, but they didn't,\n\t\t\t// so it's possible that some phone number formats\n\t\t\t// will be falsely rejected until there are at least\n\t\t\t// 3 digits in the national (significant) number being input.\n\n\t\t\tif (leading_digits.length <= MIN_LEADING_DIGITS_LENGTH)\n\t\t\t{\n\t\t\t\treturn this.available_formats\n\t\t\t}\n\n\t\t\treturn this.matching_formats\n\t\t}\n\n\t\t// Check to see if there is an exact pattern match for these digits. If so, we\n\t\t// should use this instead of any other formatting template whose\n\t\t// leadingDigitsPattern also matches the input.\n\t\tattempt_to_format_complete_phone_number()\n\t\t{\n\t\t\tfor (let format of this.get_relevant_phone_number_formats())\n\t\t\t{\n\t\t\t\tconst matcher = new RegExp('^(?:' + get_format_pattern(format) + ')$')\n\n\t\t\t\tif (!matcher.test(this.national_number))\n\t\t\t\t{\n\t\t\t\t\t// If the national prefix is optional\n\t\t\t\t\t// then also try to format the phone number\n\t\t\t\t\t// without the national prefix being extracted.\n\t\t\t\t\tif (this.national_prefix\n\t\t\t\t\t\t&& get_format_national_prefix_is_optional_when_formatting(format, this.country_metadata))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!matcher.test(this.national_prefix + this.national_number))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.national_number = this.national_prefix + this.national_number\n\t\t\t\t\t\tthis.national_prefix = ''\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif (!this.validate_format(format))\n\t\t\t\t{\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// To leave the formatter in a consistent state\n\t\t\t\tthis.reset_format()\n\t\t\t\tthis.chosen_format = format\n\n\t\t\t\tconst formatted_number = format_national_number_using_format\n\t\t\t\t(\n\t\t\t\t\tthis.national_number,\n\t\t\t\t\tformat,\n\t\t\t\t\tthis.is_international(),\n\t\t\t\t\tthis.national_prefix.length > 0,\n\t\t\t\t\tthis.country_metadata\n\t\t\t\t)\n\n\t\t\t\t// Set `this.template` and `this.partially_populated_template`\n\t\t\t\t//\n\t\t\t\t// `else` case doesn't ever happen\n\t\t\t\t// with the current metadata,\n\t\t\t\t// but just in case.\n\t\t\t\t//\n\t\t\t\t/* istanbul ignore else */\n\t\t\t\tif (this.create_formatting_template(format))\n\t\t\t\t{\n\t\t\t\t\t// Populate `this.partially_populated_template`\n\t\t\t\t\tthis.reformat_national_number()\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconst full_number = this.full_phone_number(formatted_number)\n\n\t\t\t\t\tthis.template = full_number.replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER)\n\t\t\t\t\tthis.partially_populated_template = full_number\n\t\t\t\t}\n\n\t\t\t\treturn formatted_number\n\t\t\t}\n\t\t}\n\n\t\t// Combines the national number with the appropriate prefix\n\t\tfull_phone_number(formatted_national_number)\n\t\t{\n\t\t\tif (this.is_international())\n\t\t\t{\n\t\t\t\treturn `+${this.country_phone_code} ${formatted_national_number}`\n\t\t\t}\n\n\t\t\treturn formatted_national_number\n\t\t}\n\n\t\t// Extracts the country calling code from the beginning\n\t\t// of the entered `national_number` (so far),\n\t\t// and places the remaining input into the `national_number`.\n\t\textract_country_phone_code()\n\t\t{\n\t\t\tif (!this.national_number)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst { country_phone_code, number } = parse_phone_number_and_country_phone_code(this.parsed_input, metadata)\n\n\t\t\tif (!country_phone_code)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.country_phone_code = country_phone_code\n\t\t\tthis.national_number = number\n\n\t\t\treturn this.country_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata)\n\t\t}\n\n\t\textract_national_prefix()\n\t\t{\n\t\t\tthis.national_prefix = ''\n\n\t\t\tif (!this.country_metadata)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst national_prefix_for_parsing = get_national_prefix_for_parsing(this.country_metadata)\n\n\t\t\tif (!national_prefix_for_parsing)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst matches = this.national_number.match(new RegExp('^(?:' + national_prefix_for_parsing + ')'))\n\n\t\t\t// Since some national prefix patterns are entirely optional, check that a\n\t\t\t// national prefix could actually be extracted.\n\t\t\tif (!matches || !matches[0])\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst national_number_starts_at = matches[0].length\n\n\t\t\tthis.national_prefix = this.national_number.slice(0, national_number_starts_at)\n\t\t\tthis.national_number = this.national_number.slice(national_number_starts_at)\n\n\t\t\treturn this.national_prefix\n\t\t}\n\n\t\tchoose_another_format()\n\t\t{\n\t\t\t// When there are multiple available formats, the formatter uses the first\n\t\t\t// format where a formatting template could be created.\n\t\t\tfor (let format of this.get_relevant_phone_number_formats())\n\t\t\t{\n\t\t\t\t// If this format is currently being used\n\t\t\t\t// and is still possible, then stick to it.\n\t\t\t\tif (this.chosen_format === format)\n\t\t\t\t{\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// If this `format` is suitable for \"as you type\",\n\t\t\t\t// then extract the template from this format\n\t\t\t\t// and use it to format the phone number being input.\n\n\t\t\t\tif (!this.validate_format(format))\n\t\t\t\t{\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif (!this.create_formatting_template(format))\n\t\t\t\t{\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tthis.chosen_format = format\n\n\t\t\t\t// With a new formatting template, the matched position\n\t\t\t\t// using the old template needs to be reset.\n\t\t\t\tthis.last_match_position = -1\n\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\t// No format matches the phone number,\n\t\t\t// therefore set `country` to `undefined`\n\t\t\t// (or to the default country).\n\t\t\tthis.reset_country()\n\n\t\t\t// No format matches the national phone number entered\n\t\t\tthis.reset_format()\n\t\t}\n\n\t\tvalidate_format(format)\n\t\t{\n\t\t\t// If national prefix is mandatory for this phone number format\n\t\t\t// and the user didn't input the national prefix,\n\t\t\t// then this phone number format isn't suitable.\n\t\t\tif (!this.is_international() && !this.national_prefix && get_format_national_prefix_is_mandatory_when_formatting(format, this.country_metadata))\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treturn true\n\t\t}\n\n\t\tcreate_formatting_template(format)\n\t\t{\n\t\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\n\t\t\t// (20|3)\\d{4}. In those cases we quickly return.\n\t\t\t// (Though there's no such format in current metadata)\n\t\t\t/* istanbul ignore if */\n\t\t\tif (get_format_pattern(format).indexOf('|') >= 0)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst national_prefix_formatting_rule = get_format_national_prefix_formatting_rule(format, this.country_metadata)\n\n\t\t\t// A very smart trick by the guys at Google\n\t\t\tconst number_pattern = get_format_pattern(format)\n\t\t\t\t// Replace anything in the form of [..] with \\d\n\t\t\t\t.replace(CHARACTER_CLASS_PATTERN, '\\\\d')\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\n\t\t\t\t.replace(STANDALONE_DIGIT_PATTERN, '\\\\d')\n\n\t\t\t// This match will always succeed,\n\t\t\t// because the \"longest dummy phone number\"\n\t\t\t// has enough length to accomodate any possible\n\t\t\t// national phone number format pattern.\n\t\t\tconst dummy_phone_number_matching_format_pattern = LONGEST_DUMMY_PHONE_NUMBER.match(number_pattern)[0]\n\n\t\t\t// If the national number entered is too long\n\t\t\t// for any phone number format, then abort.\n\t\t\tif (this.national_number.length > dummy_phone_number_matching_format_pattern.length)\n\t\t\t{\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Now prepare phone number format\n\t\t\tlet number_format = this.get_format_format(format)\n\n\t\t\t// If the user did input the national prefix\n\t\t\t// then maybe make it a part of the phone number template\n\t\t\tif (this.national_prefix)\n\t\t\t{\n\t\t\t\tconst national_prefix_formatting_rule = get_format_national_prefix_formatting_rule(format, this.country_metadata)\n\n\t\t\t\t// If national prefix formatting rule is set\n\t\t\t\t// for this phone number format\n\t\t\t\tif (national_prefix_formatting_rule)\n\t\t\t\t{\n\t\t\t\t\t// Make the national prefix a part of the phone number template\n\t\t\t\t\tnumber_format = number_format.replace(FIRST_GROUP_PATTERN, national_prefix_formatting_rule)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Get a formatting template which can be used to efficiently format\n\t\t\t// a partial number where digits are added one by one.\n\n\t\t\t// Create formatting template for this phone number format\n\t\t\tlet template = dummy_phone_number_matching_format_pattern\n\t\t\t\t// Format the dummy phone number according to the format\n\t\t\t\t.replace(new RegExp(number_pattern, 'g'), number_format)\n\t\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER\n\t\t\t\t.replace(DUMMY_DIGIT_MATCHER, DIGIT_PLACEHOLDER)\n\n\t\t\t// This one is for national number only\n\t\t\tthis.partially_populated_template = template\n\n\t\t\t// For convenience, the public `.template` property\n\t\t\t// is gonna contain the whole international number\n\t\t\t// if the phone number being input is international.\n\t\t\tif (this.is_international())\n\t\t\t{\n\t\t\t\ttemplate = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.country_phone_code.length) + ' ' + template\n\t\t\t}\n\t\t\t// For local numbers, replace national prefix\n\t\t\t// with a digit placeholder.\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemplate = template.replace(/\\d/g, DIGIT_PLACEHOLDER)\n\t\t\t}\n\n\t\t\t// This one is for the full phone number\n\t\t\treturn this.template = template\n\t\t}\n\n\t\tformat_next_national_number_digits(digits)\n\t\t{\n\t\t\tfor (let digit of digits)\n\t\t\t{\n\t\t\t\t// If there is room for more digits in current `template`,\n\t\t\t\t// then set the next digit in the `template`,\n\t\t\t\t// and return the formatted digits so far.\n\n\t\t\t\t// If more digits are entered than the current format could handle\n\t\t\t\tif (this.partially_populated_template.slice(this.last_match_position + 1).search(DIGIT_PLACEHOLDER_MATCHER) === -1)\n\t\t\t\t{\n\t\t\t\t\t// Reset the current format,\n\t\t\t\t\t// so that the new format will be chosen\n\t\t\t\t\t// in a subsequent `this.choose_another_format()` call\n\t\t\t\t\t// later in code.\n\t\t\t\t\tthis.chosen_format = undefined\n\t\t\t\t\tthis.template = undefined\n\t\t\t\t\tthis.partially_populated_template = undefined\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tthis.last_match_position = this.partially_populated_template.search(DIGIT_PLACEHOLDER_MATCHER)\n\t\t\t\tthis.partially_populated_template = this.partially_populated_template.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\n\t\t\t}\n\n\t\t\t// Return the formatted phone number so far\n\t\t\treturn close_dangling_braces(this.partially_populated_template, this.last_match_position + 1)\n\t\t\t\t.replace(DIGIT_PLACEHOLDER_MATCHER_GLOBAL, ' ')\n\t\t}\n\n\t\tis_international()\n\t\t{\n\t\t\treturn this.parsed_input && this.parsed_input[0] === '+'\n\t\t}\n\n\t\tget_format_format(format)\n\t\t{\n\t\t\tif (this.is_international())\n\t\t\t{\n\t\t\t\treturn local_to_international_style(get_format_international_format(format))\n\t\t\t}\n\n\t\t\treturn get_format_format(format)\n\t\t}\n\n\t\t// Determines the country of the phone number\n\t\t// entered so far based on the country phone code\n\t\t// and the national phone number.\n\t\tdetermine_the_country()\n\t\t{\n\t\t\tthis.country = find_country_code(this.country_phone_code, this.national_number, metadata)\n\t\t}\n\t}\n\n\tas_you_type.DIGIT_PLACEHOLDER = DIGIT_PLACEHOLDER\n\n\treturn as_you_type\n}\n\nexport function close_dangling_braces(template, cut_before)\n{\n\tconst retained_template = template.slice(0, cut_before)\n\n\tconst opening_braces = count_occurences('(', retained_template)\n\tconst closing_braces = count_occurences(')', retained_template)\n\n\tlet dangling_braces = opening_braces - closing_braces\n\n\twhile (dangling_braces > 0 && cut_before < template.length)\n\t{\n\t\tif (template[cut_before] === ')')\n\t\t{\n\t\t\tdangling_braces--\n\t\t}\n\t\tcut_before++\n\t}\n\n\treturn template.slice(0, cut_before)\n}\n\n// Counts all occurences of a symbol in a string\nexport function count_occurences(symbol, string)\n{\n\tlet count = 0\n\n\tfor (let character of string)\n\t{\n\t\tif (character === symbol)\n\t\t{\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}\n\n// Repeats a string (or a symbol) N times.\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\nexport function repeat(string, times)\n{\n\tif (times < 1)\n\t{\n\t\treturn ''\n\t}\n\n\tlet result = ''\n\n\twhile (times > 1)\n\t{\n\t\tif (times & 1)\n\t\t{\n\t\t\tresult += string\n\t\t}\n\n\t\ttimes >>= 1\n\t\tstring += string\n\t}\n\n\treturn result + string\n}"]}